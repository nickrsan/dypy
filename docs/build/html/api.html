

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DyPy API &mdash; DyPy 0.0.3b documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="DyPy Examples" href="examples.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> DyPy
          

          
          </a>

          
            
            
              <div class="version">
                0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="conceptual_overview.html">DyPy Core Concepts and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">DyPy Examples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">DyPy API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-dypy">DyPy Core</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-dypy.variables">DyPy Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-dypy.reducers">DyPy State Variable Reducers</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">DyPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>DyPy API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dypy-api">
<span id="code"></span><h1>DyPy API<a class="headerlink" href="#dypy-api" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="#module-dypy" title="dypy"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dypy</span></code></a> Package</p>
<div class="section" id="module-dypy">
<span id="dypy-core"></span><h2>DyPy Core<a class="headerlink" href="#module-dypy" title="Permalink to this headline">¶</a></h2>
<p>Dynamic Program class - implements only backward dynamic programming.
Ideal usage is to have an objective function defined by the user, however they’d like.</p>
<p>The user defines as many StateVariable instances as they have state variables in their DP and they define
a DecisionVariable. The objective function should be prepared to take arguments with keyword values for each of
these, where the keyword is determined by the name attribute on each instance. It then returns a value.</p>
<p>For situations with multiple state variables, we have reducers, which, prior to minimization or maximization
will reduce the number of state variables to one so that we can get a single F* for each input scenario.
This is a class Reducer with a defined interface, and can then be extended. For our levee problem, we have a
ProbabilisticReducer which keeps track of the probability of each set of state variables and can collapse by
a master variable. Probabilities must be provided by the user.</p>
<p># TODO: Make sure to check how we can make the decision variable properly interact with the state variable - thinking
# of making sure that the decision variable adds to the correct state variable items
# TODO: Missing plan for how we assign probabilities here - needs to be incorporated somewhere
# TODO: Missing choice constraints (eg, minimim possible selection at stage ___ is ___)</p>
<p>At that point, usage for the levee problem should be something like:</p>
<p>``
import support  # user’s extra code to support the objective function
import dypy as dp</p>
<p>objective_function = support.objective_function
height_var = dp.StateVariable(“height”)
flow_var = dp.StateVariable(“peak_flow”)
variance_var = dp.StateVariable(“variance”)
decision_var = dp.DecisionVariable()
decision_var.related_state = height_var  # tell the decision variable which state it impacts</p>
<dl class="docutils">
<dt>dynamic_program = dp.DynamicProgram(objective_function=objective_function,</dt>
<dd>state_variables=(height_var, flow_var, variance_var),
decison_variable=decision_var)</dd>
</dl>
<p>dynamic_program.optimize()  # runs the backward recursion
dynamic_program.get_optimal_values()  # runs the forward method to obtain choices
``</p>
<dl class="class">
<dt id="dypy.DynamicProgram">
<em class="property">class </em><code class="descclassname">dypy.</code><code class="descname">DynamicProgram</code><span class="sig-paren">(</span><em>objective_function=&lt;function default_objective&gt;</em>, <em>timestep_size=None</em>, <em>time_horizon=None</em>, <em>discount_rate=0</em>, <em>state_variables=None</em>, <em>max_selections=None</em>, <em>selection_constraints=None</em>, <em>decision_variable=None</em>, <em>calculation_function=None</em>, <em>prior=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#DynamicProgram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.DynamicProgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This object actually runs the DP - doesn’t currently support multiple decision variables or probabilities.</p>
<p>Currently designed to only handle backward DPs.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd>DynamicProgram.stages   list of Stage objects</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>objective_function</strong> – What function provides values to populate each cell in each stage? Not required if
you build your own stages with their own values</li>
<li><strong>selection_constraints</strong> – Is there a minimum value that must be achieved in the selection?
If so, this should be a list with the required quantity at each time step</li>
<li><strong>decision_variables</strong> – list of DecisionVariable objects</li>
<li><strong>discount_rate</strong> – give the discount rate in “annual” units. Though timesteps don’t need to be in years, think
of the discount rate as applying per smallest possible timestep size, so if your timestep_size is 40, then
your discount rate will be transformed to cover 40 timesteps (compounding).</li>
<li><strong>calculation_function</strong> – What function are we using to evaluate? Basically, is this a maximization (benefit)
or minimization (costs) setup. Provide the function object for max or min. Provide the actual <cite>min</cite> or <a href="#id1"><span class="problematic" id="id2">`</span></a>max functions
(don’t run it, just the name) or if convenient, use the shortcuts dp.MINIMIZE or dp.MAXIMIZE</li>
<li><strong>max_selections</strong> – Up to what value of the state variable can we use to make our decision? If not provided,
all values of the state variable will be allowed</li>
<li><strong>prior</strong> – Which class should be used to handle priors (best values from future stages) - SimplePrior is best in many
cases, but may not apply everywhere and will be slow for large tables. Just provide the class object, not an instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dypy.DynamicProgram.add_stage">
<code class="descname">add_stage</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#DynamicProgram.add_stage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.DynamicProgram.add_stage" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Adds an empty stage to this DynamicProgram, tied to the currently set DecisionVariable and Prior classes
associated with this DynamicProgram. Gives the stage the name provided as a parameter, usually generated
automatically by the DP.</p>
<p>This method is called automatically by default, but is exposed as a public method primarily so you can
control its usage if you desire, or so you can override its behavior in a subclass (such as if you wish
to manually handle Stage creation in order to control the process for a specific dynamic programming problem).</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> – The name associated with the stage. Generated by the name prefix and the stage ID when called via build_stages</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dypy.DynamicProgram.add_state_variable">
<code class="descname">add_state_variable</code><span class="sig-paren">(</span><em>variable</em>, <em>setup_state=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#DynamicProgram.add_state_variable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.DynamicProgram.add_state_variable" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Adds a state variable object to this dynamic program - automatically sets up the dynamic program
to run with the new state variable when setup_state is True. Otherwise waits for you to call it manually.
If you provide your state variables at DynamicProgram creation, then this method does not need to be called.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> – A StateVariable object - afterward, will be available in .state_variables</li>
<li><strong>setup_state</strong> – If True, runs _setup_state_variables after finishing. Default is True,
but when adding a bunch of state variables, it’s faster just to manually
run it once at the end. It runs it by default so that for simple DPs, you
don’t need to think about it, but advanced, larger DPs, may wnat to set it
to False and run _setup_state_variables once all are added</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dypy.DynamicProgram.build_stages">
<code class="descname">build_stages</code><span class="sig-paren">(</span><em>name_prefix='Step'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#DynamicProgram.build_stages"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.DynamicProgram.build_stages" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Make a stage for every timestep</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name_prefix</strong> – The string that will go before the stage number when printing information</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dypy.DynamicProgram.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#DynamicProgram.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.DynamicProgram.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dypy.Prior">
<em class="property">class </em><code class="descclassname">dypy.</code><code class="descname">Prior</code><span class="sig-paren">(</span><em>stage</em>, <em>data=None</em>, <em>matrix=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#Prior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.Prior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class for applying future stage values back to the previous stage</p>
<dl class="method">
<dt id="dypy.Prior.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#Prior.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.Prior.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dypy.Prior.exists">
<code class="descname">exists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#Prior.exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.Prior.exists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dypy.SimplePrior">
<em class="property">class </em><code class="descclassname">dypy.</code><code class="descname">SimplePrior</code><span class="sig-paren">(</span><em>stage</em>, <em>data=None</em>, <em>matrix=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#SimplePrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.SimplePrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dypy.Prior" title="dypy.Prior"><code class="xref py py-class docutils literal notranslate"><span class="pre">dypy.Prior</span></code></a></p>
<p>A simple implementation of the prior class - given a single set of optimal values from the future stage (as a 1D
numpy array), it applies these values to the previous stage by flipping the axis of the decision
and shifting the values down by 1 as we move across the decisions.</p>
<p>This prior application method <em>won’t</em> work for multiple state variables or for state variables with different
discretization than decision variables. For more advanced situations with multiple states, we’ll need to use
the linked_state attribute on the decision variables to understand how to apply priors. This functionality
may need to be re-engineered or expanded.</p>
<dl class="method">
<dt id="dypy.SimplePrior.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#SimplePrior.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.SimplePrior.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dypy.Stage">
<em class="property">class </em><code class="descclassname">dypy.</code><code class="descname">Stage</code><span class="sig-paren">(</span><em>name</em>, <em>decision_variable</em>, <em>parent_dp</em>, <em>previous=None</em>, <em>next_stage=None</em>, <em>prior_handler=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#Stage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.Stage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="dypy.Stage.build">
<code class="descname">build</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#Stage.build"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.Stage.build" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Builds the stage table - evaluates the objective function for each location, passing the various
values to it so it can provide a result. Does <em>not</em> handle prior data though - that is handled when
we actually run the DP. We separate this out so that people who want to intervene between generating
the stage table and handling the prior can do so.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dypy.Stage.create_prior_handler">
<code class="descname">create_prior_handler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#Stage.create_prior_handler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.Stage.create_prior_handler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dypy.Stage.get_optimal_values">
<code class="descname">get_optimal_values</code><span class="sig-paren">(</span><em>prior=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#Stage.get_optimal_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.Stage.get_optimal_values" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>After running the backward DP, moves forward and finds the best choices at each stage.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>prior</strong> – The value of the choice at each stage</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dypy.Stage.optimize">
<code class="descname">optimize</code><span class="sig-paren">(</span><em>prior=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#Stage.optimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.Stage.optimize" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>This handles the actual backward DP calculation - assumes that the stage has a matrix that is built
already with appropriate values.</p>
<dl class="docutils">
<dt>This method will handle migrating prior data back through. As notes:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>We should be able to do a lot of this with numpy broadcasting. If we take the calculation function</dt>
<dd><p class="first last">of each row in the previous stage, then broadcast it across this stage, that should do it.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Need to think about where reducers fit in - if we have a probabilistic reducer, that can run after</dt>
<dd><p class="first last">we do the broadcasting, I believe.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Need to figure out how we want to handle both selection constraints, but also decision/state interactions</dt>
<dd><p class="first">Right now, we can say which state a decision feeds back on - but what’s going through my head about that
is: 1) Do we need that if we expect an objective function? I think we do because that determines</p>
<blockquote class="last">
<div><p>how we take values from the future and propogate them backward. This is where maybe we
might not actually be able to use numpy broadcasting? Or maybe we have to shift the array
we’re broadcasting to align based on the best decision - not sure - need to think of how
we’re going to handle that a bit more
2) What about where there’s some limit imposed by decision var / state var interaction. For</p>
<blockquote>
<div><p>example, with the course studying test problem - in the last stage, the state variable
can’t be less than the decision variable. Maybe that’s always the case though, and is
only a last stage problem?</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>prior</strong> – </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dypy.default_objective">
<code class="descclassname">dypy.</code><code class="descname">default_objective</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy.html#default_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.default_objective" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>A bare objective function that makes all cells 0 - provided as a default so we can build stages where someone
might do a manual override, but the DP should check to make sure the objective isn’t the default with all cells
at 0 before solving.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> – </li>
<li><strong>kwargs</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-dypy.variables">
<span id="dypy-variables"></span><h2>DyPy Variables<a class="headerlink" href="#module-dypy.variables" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dypy.variables.DecisionVariable">
<em class="property">class </em><code class="descclassname">dypy.variables.</code><code class="descname">DecisionVariable</code><span class="sig-paren">(</span><em>name</em>, <em>variable_id=None</em>, <em>related_state=None</em>, <em>minimum=None</em>, <em>maximum=None</em>, <em>step_size=None</em>, <em>options=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy/variables.html#DecisionVariable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.variables.DecisionVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="dypy.variables.DecisionVariable.add_constraint">
<code class="descname">add_constraint</code><span class="sig-paren">(</span><em>stage</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy/variables.html#DecisionVariable.add_constraint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.variables.DecisionVariable.add_constraint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Want to figure out a way here to store also whether this constraint is a minimum or a maximum value constraint.
Need to think how we’d handle that behavior</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stage</strong> – </li>
<li><strong>value</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dypy.variables.DecisionVariable.maximum">
<code class="descname">maximum</code><a class="headerlink" href="#dypy.variables.DecisionVariable.maximum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dypy.variables.DecisionVariable.minimum">
<code class="descname">minimum</code><a class="headerlink" href="#dypy.variables.DecisionVariable.minimum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dypy.variables.DecisionVariable.options">
<code class="descname">options</code><a class="headerlink" href="#dypy.variables.DecisionVariable.options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dypy.variables.DecisionVariable.step_size">
<code class="descname">step_size</code><a class="headerlink" href="#dypy.variables.DecisionVariable.step_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dypy.variables.StateVariable">
<em class="property">class </em><code class="descclassname">dypy.variables.</code><code class="descname">StateVariable</code><span class="sig-paren">(</span><em>name</em>, <em>values</em>, <em>variable_id=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy/variables.html#StateVariable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.variables.StateVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Not sure what I’m going to do with this yet, but I think we’ll need it in order to have rows for interactions
between multiple state variables.</p>
<p>When we go to use all the state variables together, we’ll need to discretize them each, and then we’ll need to combine
them to get all the rows in the table for each stage. Assuming we have some attribute .discretized that contains
all the values for this state variable and that the DynamicProgram class has a list of these state variables called
.state_variables, we can get all possible combinations for generating a row using <cite>itertools.product(*[var.discretized for var in self.state_variables])</cite>
Note the asterisk at the front, which takes that list and expands it so each one is an individual argument to
itertools.product</p>
<p>We can then use this by taking the name attribute of the state variable and passing it as the kwarg to the objective
function along with the discretized value. So then we have a DP class that accepts a list of variables, an objective
function, and then a preprocessor function that handles aggregation of choices between filling in the matrix
and use of minimization (a function that accepts the array and reduces the choices so that we can actually minimize
or maximize. We need this to reduce multiple state variables to a single state variable.</p>
</dd></dl>

<dl class="function">
<dt id="dypy.variables.check_variable_id">
<code class="descclassname">dypy.variables.</code><code class="descname">check_variable_id</code><span class="sig-paren">(</span><em>name</em>, <em>variable_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy/variables.html#check_variable_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.variables.check_variable_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-dypy.reducers">
<span id="dypy-state-variable-reducers"></span><h2>DyPy State Variable Reducers<a class="headerlink" href="#module-dypy.reducers" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dypy.reducers.ProbabilisticReducer">
<em class="property">class </em><code class="descclassname">dypy.reducers.</code><code class="descname">ProbabilisticReducer</code><a class="reference internal" href="_modules/dypy/reducers.html#ProbabilisticReducer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.reducers.ProbabilisticReducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dypy.reducers.Reducer" title="dypy.reducers.Reducer"><code class="xref py py-class docutils literal notranslate"><span class="pre">dypy.reducers.Reducer</span></code></a></p>
<p>Given a StateVariable to process (S), and a set of StateVariables to hold constant (Cs), reduces S for each
combination of Cs by multiplying the objective values in the records for S by their probabilities and summing them.</p>
<p>We should be able to actually just make this have a single column for probabilities so that we can do the same
thing we planned to do for the variable reducer and just (ignoring the first paragraph of this docstring)
select a master variable, get all rows for it, multiply those rows by the probability field, and sum them up.</p>
</dd></dl>

<dl class="class">
<dt id="dypy.reducers.Reducer">
<em class="property">class </em><code class="descclassname">dypy.reducers.</code><code class="descname">Reducer</code><a class="reference internal" href="_modules/dypy/reducers.html#Reducer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.reducers.Reducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Reduces multiple state variables to a single state variable so we can just minimize</p>
</dd></dl>

<dl class="class">
<dt id="dypy.reducers.VariableReducer">
<em class="property">class </em><code class="descclassname">dypy.reducers.</code><code class="descname">VariableReducer</code><span class="sig-paren">(</span><em>variable</em>, <em>stage</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dypy/reducers.html#VariableReducer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dypy.reducers.VariableReducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dypy.reducers.Reducer" title="dypy.reducers.Reducer"><code class="xref py py-class docutils literal notranslate"><span class="pre">dypy.reducers.Reducer</span></code></a></p>
<p>Given a StateVariable, reduces the table size by collapsing all other variables - can do this by min/max/mean/sum
of all options.</p>
<p>Saving implementation here until after we have a better sense for how the rest of this will be implemented</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="examples.html" class="btn btn-neutral" title="DyPy Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Nick Santos

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>